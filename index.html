<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="/src/style.css" rel="stylesheet" />
    <title>Sleeper League Viewer</title>
    <style>
      /* Use the Inter font family */
      body {
        font-family: 'Inter', sans-serif;
      }
      /* Simple loading spinner */
      .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border-left-color: #09f;
        animation: spin 1s ease infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body class="bg-gray-100 min-h-screen text-gray-800 p-4 md:p-8">
    <div class="max-w-7xl mx-auto">
      <!-- Header -->
      <header class="mb-6">
        <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Sleeper Guillotine League Viewer</h1>
        <p class="text-lg text-gray-600">Enter your league ID and a week to see all rosters and points.</p>
      </header>

      <!-- Input Form -->
      <div class="bg-white p-6 rounded-lg shadow-md mb-8">
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
          <div class="md:col-span-2">
            <label for="leagueId" class="block text-sm font-medium text-gray-700 mb-1">League ID</label>
            <input
              type="text"
              id="leagueId"
              value="1256757130514415616"
              class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
            />
          </div>
          <div>
            <label for="week" class="block text-sm font-medium text-gray-700 mb-1">Week</label>
            <input
              type="number"
              id="week"
              value="1"
              min="1"
              max="18"
              class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
            />
          </div>
          <div class="flex items-end">
            <button
              id="fetchButton"
              class="w-full bg-blue-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-150 ease-in-out"
            >
              Fetch League Data
            </button>
          </div>
        </div>
      </div>

      <!-- Loading and Message Area -->
      <div id="messageArea" class="text-center my-6 hidden">
        <div class="flex justify-center items-center">
          <div class="spinner mr-3"></div>
          <span id="messageText" class="text-lg font-medium text-gray-700">Loading...</span>
        </div>
      </div>

      <!-- League Info Header -->
      <div id="leagueInfo" class="mb-6 hidden">
        <h2 id="leagueName" class="text-2xl font-bold"></h2>
        <p id="leagueDetails" class="text-md text-gray-600"></p>
      </div>

      <!-- Results Grid -->
      <div id="results" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <!-- Team cards will be injected here by JavaScript -->
      </div>

      <!-- Eliminated Teams Section -->
      <div id="eliminatedSection" class="mt-12 hidden">
        <h2 class="text-2xl font-bold mb-4 border-b pb-2 text-gray-700">Eliminated Teams</h2>
        <div id="eliminatedList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          <!-- Eliminated team cards will be injected here -->
        </div>
      </div>
    </div>

    <script type="module">
      // --- Globals ---
      // Cache for all NFL players data. This is a large file and should only be fetched once.
      let allPlayersData = null;
      const API_BASE = 'https://api.sleeper.app/v1';
      const ESPN_REGULAR_SEASON_TYPE = 2; // ESPN API constant for regular season

      // Team abbreviation mapping: Sleeper -> ESPN
      // Most teams use the same abbreviations, but Jacksonville differs
      const TEAM_ABBR_SLEEPER_TO_ESPN = {
        JAC: 'JAX', // Jacksonville: Sleeper uses JAC, ESPN uses JAX
      };

      // Convert Sleeper team abbreviation to ESPN abbreviation
      function convertTeamAbbr(sleeperAbbr) {
        return TEAM_ABBR_SLEEPER_TO_ESPN[sleeperAbbr] || sleeperAbbr;
      }

      // Calculate current NFL week based on date
      function getCurrentNFLWeek() {
        const today = new Date();
        // Week 1 starts on September 5th, 2025
        const seasonStart = new Date(2025, 8, 2); // Month is 0-based, so 8 is September
        const diffTime = Math.abs(today - seasonStart);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        const currentWeek = Math.ceil(diffDays / 7);
        return Math.min(Math.max(currentWeek, 1), 18); // Ensure week is between 1 and 18
      }

      // --- DOM Elements ---
      const leagueIdInput = document.getElementById('leagueId');
      const weekInput = document.getElementById('week');
      const fetchButton = document.getElementById('fetchButton');
      const messageArea = document.getElementById('messageArea');
      const messageText = document.getElementById('messageText');
      const resultsDiv = document.getElementById('results');
      const leagueInfoDiv = document.getElementById('leagueInfo');
      const leagueNameEl = document.getElementById('leagueName');
      const leagueDetailsEl = document.getElementById('leagueDetails');
      const eliminatedSection = document.getElementById('eliminatedSection');
      const eliminatedList = document.getElementById('eliminatedList');

      // --- Event Listeners ---
      document.addEventListener('DOMContentLoaded', () => {
        weekInput.value = getCurrentNFLWeek();
      });
      fetchButton.addEventListener('click', handleFetchData);

      // --- Main Function ---
      async function handleFetchData() {
        const leagueId = leagueIdInput.value.trim();
        const week = weekInput.value;

        if (!leagueId || !week) {
          showMessage('Please enter both a League ID and a Week.', true);
          return;
        }

        setLoading(true, 'Fetching league data...');
        clearResults();

        try {
          // 1. Fetch all players (if not already cached)
          // This is the largest request and is cached globally
          if (!allPlayersData) {
            setLoading(true, 'Fetching all NFL player data (first-time load, may take a moment)...');
            allPlayersData = await fetchData('players_pruned.json');
          }

          // 2. Fetch league-specific data
          setLoading(true, 'Fetching league, rosters, and users...');
          const leagueData = await fetchData(`${API_BASE}/league/${leagueId}`);
          const leagueRosters = await fetchData(`${API_BASE}/league/${leagueId}/rosters`);
          const leagueUsers = await fetchData(`${API_BASE}/league/${leagueId}/users`);

          // 3. Fetch stats for the specific week
          const season = leagueData.season;
          setLoading(true, `Fetching stats for ${season} Season, Week ${week}...`);
          const weeklyStats = await fetchData(`${API_BASE}/stats/nfl/regular/${season}/${week}`);

          // 3b. Fetch Projections for the week
          setLoading(true, `Fetching projections for Week ${week}...`);
          const weeklyProjections = await fetchData(`${API_BASE}/projections/nfl/regular/${season}/${week}`);

          // 3c. Fetch NFL schedule for the week using ESPN API
          setLoading(true, 'Fetching NFL schedule...');
          const espnScheduleUrl = `https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?seasontype=${ESPN_REGULAR_SEASON_TYPE}&week=${week}`;
          const espnScheduleData = await fetchData(espnScheduleUrl);

          // Convert ESPN schedule data to a quick-lookup map with opponent information
          const scheduleMap = {};
          if (espnScheduleData?.events) {
            for (const event of espnScheduleData.events) {
              if (!event.competitions || !event.competitions[0]) continue;

              const competition = event.competitions[0];
              const competitors = competition.competitors;

              // Find home and away teams
              const homeTeam = competitors.find((c) => c.homeAway === 'home');
              const awayTeam = competitors.find((c) => c.homeAway === 'away');

              if (!homeTeam || !awayTeam) continue;

              // Get team abbreviations from ESPN
              const homeAbbr = homeTeam.team?.abbreviation;
              const awayAbbr = awayTeam.team?.abbreviation;

              // Determine game status
              let status = 'pre_game';
              const statusName = competition.status?.type?.name;
              if (statusName === 'STATUS_IN_PROGRESS') {
                status = 'inprogress';
              } else if (statusName === 'STATUS_FINAL') {
                status = 'post_game';
              } else if (competition.status?.type?.state === 'in') {
                status = 'inprogress';
              } else if (competition.status?.type?.state === 'post') {
                status = 'post_game';
              }

              if (homeAbbr) {
                scheduleMap[homeAbbr] = {
                  status: status,
                  game_id: event.id,
                  opponent: awayAbbr,
                  isHome: true,
                };
              }

              if (awayAbbr) {
                scheduleMap[awayAbbr] = {
                  status: status,
                  game_id: event.id,
                  opponent: homeAbbr,
                  isHome: false,
                };
              }
            }
          }

          // 4. Process and Render
          setLoading(true, 'Processing and rendering rosters...');
          processAndRender(leagueData, leagueRosters, leagueUsers, weeklyStats, weeklyProjections, scheduleMap, allPlayersData, week);
        } catch (error) {
          console.error('Error fetching league data:', error);
          showMessage(`Error: ${error.message}. Check League ID and console for details.`, true);
        } finally {
          setLoading(false);
        }
      }

      // --- Data Fetching Utility ---
      async function fetchData(url) {
        const response = await fetch(url);
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ message: response.statusText }));
          throw new Error(errorData.message || `Failed to fetch ${url}`);
        }
        return await response.json();
      }

      // --- Data Processing and Rendering ---
      function processAndRender(league, rosters, users, stats, projections, scheduleMap, allPlayers, week) {
        // Display league info
        leagueNameEl.textContent = league.name;
        leagueDetailsEl.textContent = `${league.season} Season | Week ${week} | ${league.total_rosters} Teams`;
        leagueInfoDiv.classList.remove('hidden');

        // Find scoring format
        const scoringKey = getScoringKey(league.scoring_settings);

        // Create a quick-lookup map for user display names
        const userMap = users.reduce((acc, user) => {
          acc[user.user_id] = user.display_name;
          return acc;
        }, {});

        const allTeamData = [];
        const eliminatedTeams = [];

        // Loop through each roster
        for (const roster of rosters) {
          const ownerId = roster.owner_id;
          const userDisplayName = ownerId ? userMap[ownerId] : 'Team Available';
          const teamName = roster.metadata?.team_name || userDisplayName || `Team ${roster.roster_id}`;

          const owner = {
            ownerName: userDisplayName,
            teamName: teamName,
          };

          // --- NEW: Check for eliminated teams (no players) ---
          if (!roster.players || roster.players.length === 0) {
            eliminatedTeams.push(owner);
            continue; // Skip to the next roster
          }

          const playersInfo = [];

          // Loop through player IDs on this roster
          for (const playerId of roster.players) {
            const playerDetails = allPlayers[playerId];

            // Skip if player data doesn't exist (rare)
            if (!playerDetails) continue;

            const playerName = playerDetails.full_name || `${playerDetails.first_name} ${playerDetails.last_name}`;
            const position = playerDetails.position;

            // --- UPDATED POINTS LOGIC ---
            const playerTeam = playerDetails.team; // Sleeper team abbreviation
            const espnTeam = playerTeam ? convertTeamAbbr(playerTeam) : null; // Convert to ESPN abbreviation
            let gameStatus = espnTeam ? scheduleMap[espnTeam]?.status || 'none' : 'none'; // 'none' for FA or BYE

            // Get actual points
            const actualPoints = stats[playerId] && stats[playerId][scoringKey] !== undefined ? stats[playerId][scoringKey] : 0;

            // Check if game is in progress based on stats data
            // If stats exist for the player but tm_off_snp is missing, the game is in progress
            const hasStats = stats[playerId] && Object.keys(stats[playerId]).length > 0;
            const hasTmOffSnp = stats[playerId] && stats[playerId].tm_off_snp !== undefined;

            // Get projected points
            const projectedPoints =
              projections[playerId] && projections[playerId][scoringKey] !== undefined ? projections[playerId][scoringKey] : 0;

            let displayPoints = 0;
            let isProjected = false;

            // 'none' status means game isn't on the weekly schedule (e.g., future week or BYE)
            // 'pre_game' means game hasn't started.
            // In both cases, use projection.
            if (gameStatus === 'none' || gameStatus === 'pre_game') {
              displayPoints = projectedPoints;
              isProjected = true;
            } else {
              // Game is 'inprogress', 'post_game', 'halftime', etc. Use actual points.
              displayPoints = actualPoints;
            }
            // --- END UPDATED POINTS LOGIC ---

            // Get opponent information from schedule (using ESPN team abbreviation)
            const gameInfo = scheduleMap[espnTeam] || { opponent: null, isHome: false };
            const opponentDisplay = gameInfo.opponent ? (gameInfo.isHome ? `vs ${gameInfo.opponent}` : `@ ${gameInfo.opponent}`) : 'BYE';

            playersInfo.push({
              playerId: playerId, // Add playerId for tracking in optimal calculator
              name: playerName,
              position: position,
              playerTeam: playerTeam,
              opponent: opponentDisplay,
              points: displayPoints, // This will be used for calculation (mixed total)
              actualPoints: actualPoints, // Store for the "Actual Total"
              projectedPoints: projectedPoints, // Store for reference
              isProjected: isProjected, // For UI
              isStarter: false, // Will be set to true if part of optimal lineup
              gameStatus: gameStatus, // Add game status for UI display
            });
          }

          // --- NEW OPTIMAL SCORE CALCULATION ---
          // Calculate optimal score based on 1QB, 2RB, 2WR, 1TE, 2FLEX (RB/WR/TE)
          const {
            totalPoints: teamProjectedTotal,
            totalActualPoints: teamActualTotal,
            optimalStarters,
            orderedStarters,
          } = calculateOptimalScore(playersInfo);

          // Update the isStarter flag for UI highlighting based on the optimal lineup
          // We still use the Set for a quick lookup
          for (const p of playersInfo) {
            if (optimalStarters.has(p.playerId)) {
              p.isStarter = true;
            }
          }
          // --- END NEW CALCULATION ---

          // --- NEW SORTING LOGIC ---
          // Get all non-starters
          const nonStarters = playersInfo.filter((p) => !p.isStarter);
          // Sort non-starters by points (descending)
          nonStarters.sort((a, b) => b.points - a.points);

          // Combine the ordered starters (from calculateOptimalScore) with the sorted non-starters
          const sortedPlayersInfo = [...orderedStarters, ...nonStarters];
          // --- END NEW SORTING LOGIC ---

          // Add this team's data to the array instead of rendering immediately
          allTeamData.push({
            owner,
            teamTotalPoints: teamProjectedTotal, // This is the mixed total, for sorting
            teamActualTotal: teamActualTotal, // This is the pure actual total
            playersInfo: sortedPlayersInfo, // Use the new sorted list
          });
        }

        // --- NEW: Sort all teams by total points (descending) ---
        allTeamData.sort((a, b) => a.teamTotalPoints - b.teamTotalPoints);

        // --- NEW: Render the sorted teams ---
        for (const team of allTeamData) {
          createTeamCard(team.owner, team.teamTotalPoints, team.teamActualTotal, team.playersInfo);
        }

        // --- NEW: Render Eliminated Teams ---
        if (eliminatedTeams.length > 0) {
          eliminatedSection.classList.remove('hidden');
          eliminatedList.innerHTML = ''; // Clear any previous entries

          // Sort eliminated teams alphabetically by team name
          eliminatedTeams.sort((a, b) => a.teamName.localeCompare(b.teamName));

          for (const owner of eliminatedTeams) {
            createEliminatedTeamCard(owner);
          }
        }
      }

      // --- New Optimal Score Calculator ---
      /**
       * Calculates the optimal "best ball" score based on a fixed roster:
       * 1 QB, 2 RB, 2 WR, 1 TE, 2 FLEX (RB/WR/TE)
       */
      function calculateOptimalScore(allPlayersOnRoster) {
        const qbs = allPlayersOnRoster.filter((p) => p.position === 'QB').sort((a, b) => b.points - a.points);
        const rbs = allPlayersOnRoster.filter((p) => p.position === 'RB').sort((a, b) => b.points - a.points);
        const wrs = allPlayersOnRoster.filter((p) => p.position === 'WR').sort((a, b) => b.points - a.points);
        const tes = allPlayersOnRoster.filter((p) => p.position === 'TE').sort((a, b) => b.points - a.points);

        let totalPoints = 0;
        let totalActualPoints = 0; // NEW: For tracking pure actual points
        const optimalStarterIds = new Set();
        const orderedStarters = []; // NEW: Array to hold starters in order

        // Helper to add a player to the optimal lineup
        const addPlayer = (player) => {
          if (player) {
            // Use playerId to track, as it's the unique identifier
            optimalStarterIds.add(player.playerId);
            totalPoints += player.actualPoints > 0 ? player.actualPoints : player.points; // This is the mixed (display) total
            totalActualPoints += player.actualPoints; // This is the pure actual total
            orderedStarters.push(player); // Add the full player object
          }
        };

        // 1 QB
        addPlayer(qbs[0]);
        // 2 RB
        addPlayer(rbs[0]);
        addPlayer(rbs[1]);
        // 2 WR
        addPlayer(wrs[0]);
        addPlayer(wrs[1]);
        // 1 TE
        addPlayer(tes[0]);

        // 2 FLEX (RB/WR/TE)
        // Create a pool of all RBs, WRs, and TEs who haven't been used yet
        const flexPool = [...rbs, ...wrs, ...tes]
          .filter((p) => p && !optimalStarterIds.has(p.playerId)) // Check for 'p' in case a position had 0 players
          .sort((a, b) => b.points - a.points);

        addPlayer(flexPool[0]);
        addPlayer(flexPool[1]);

        return { totalPoints, totalActualPoints, optimalStarters: optimalStarterIds, orderedStarters: orderedStarters };
      }

      // --- UI Helper Functions ---

      function createTeamCard(owner, totalProjected, totalActual, players) {
        const card = document.createElement('div');
        card.className = 'bg-white shadow-lg rounded-lg p-4 overflow-hidden';

        // If totals match (to 2 decimals as displayed), show a single large green check icon to the right of totals
        const totalsMatch = totalProjected.toFixed(2) === totalActual.toFixed(2);
        const singleCheckIconHtml = totalsMatch
          ? `
            <span class="ml-3 inline-flex items-center text-green-600" title="Projected equals Actual" role="img" aria-label="Projected equals Actual">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-8 h-8">
                <path fill-rule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zm4.28 7.22a.75.75 0 00-1.06-1.06l-4.72 4.72-1.72-1.72a.75.75 0 10-1.06 1.06l2.25 2.25a.75.75 0 001.06 0l5.25-5.25z" clip-rule="evenodd" />
              </svg>
            </span>
          `
          : '';

        const playersHtml = players
          .map((p) => {
            // Build player info display string with proper spacing
            const parts = [p.name];
            if (p.playerTeam) parts.push(p.playerTeam);
            if (p.opponent) parts.push(p.opponent);
            const playerInfo = parts.join(' ');

            // Add "In Progress" indicator if game is in progress
            const inProgressBadge = p.gameStatus === 'inprogress' ? 'ðŸš§' : '';

            return `
                <li class="flex justify-between items-center py-2 ${p.isStarter ? 'font-semibold' : 'text-gray-500'}">
                    <span class="truncate" title="${p.name}">
                        ${playerInfo}
                        <span class="text-xs uppercase text-gray-400 ml-1">${p.position}</span>
                        ${inProgressBadge}
                    </span>
                    <span class="flex-shrink-0 text-right">
                        <span class="${p.isStarter ? 'text-black' : 'text-gray-500'}">${p.actualPoints.toFixed(2)}</span>
                        <span class="italic font-normal text-gray-500 ml-1">(${p.projectedPoints.toFixed(2)})</span>
                    </span>
                </li>
            `;
          })
          .join('');

        card.innerHTML = `
                <div class="border-b border-gray-200 pb-3 mb-3">
                    <h3 class="text-xl font-bold truncate" title="${owner.teamName}">${owner.teamName}</h3>
                    <div class="mt-2 flex items-center justify-between">
                      <div>
                        <p class="text-2xl font-bold text-blue-600">
                          ${totalProjected.toFixed(2)}
                          <span class="text-base font-normal text-gray-600">Projected Total</span>
                        </p>
                        <!--<p class="text-lg font-semibold text-gray-700 mt-1">
                          ${totalActual.toFixed(2)}
                          <span class="text-base font-normal text-gray-600">Actual Total</span>
                        </p>-->
                      </div>
                      <!-- ${singleCheckIconHtml} -->
                    </div>
                </div>
                <ul class="divide-y divide-gray-200">
                    ${playersHtml}
                </ul>
            `;
        resultsDiv.appendChild(card);
      }

      function createEliminatedTeamCard(owner) {
        const card = document.createElement('div');
        card.className = 'bg-white shadow-lg rounded-lg p-4';
        card.innerHTML = `
                <h3 class="text-xl font-bold truncate text-gray-500" title="${owner.teamName}">${owner.teamName}</h3>
            `;
        eliminatedList.appendChild(card);
      }

      function getScoringKey(settings) {
        // Handle cases where settings might be null or undefined
        if (!settings) {
          return 'pts_std'; // Default to standard
        }
        const recPoints = settings.rec || 0;
        if (recPoints === 1) return 'pts_ppr';
        if (recPoints === 0.5) return 'pts_half_ppr';
        return 'pts_std';
      }

      function setLoading(isLoading, message = 'Loading...') {
        if (isLoading) {
          messageArea.classList.remove('hidden');
          messageText.textContent = message;
          fetchButton.disabled = true;
          fetchButton.classList.add('opacity-50', 'cursor-not-allowed');
        } else {
          messageArea.classList.add('hidden');
          fetchButton.disabled = false;
          fetchButton.classList.remove('opacity-50', 'cursor-not-allowed');
        }
      }

      function showMessage(message, isError = false) {
        messageText.textContent = message;
        messageText.className = isError ? 'text-lg font-medium text-red-600' : 'text-lg font-medium text-gray-700';
        messageArea.classList.remove('hidden');
        // Hide spinner if it's just a message
        messageArea.querySelector('.spinner').classList.add('hidden');
      }

      function clearResults() {
        resultsDiv.innerHTML = '';
        eliminatedList.innerHTML = ''; // Clear eliminated list
        eliminatedSection.classList.add('hidden'); // Hide eliminated section
        leagueInfoDiv.classList.add('hidden');
        leagueNameEl.textContent = '';
        leagueDetailsEl.textContent = '';
        // Ensure spinner is visible when clearing for a new load
        messageArea.querySelector('.spinner').classList.remove('hidden');
      }
    </script>

    <!-- GitHub Link -->
    <div class="text-center py-8">
      <a
        href="https://github.com/mrbusche/sleeper-guillotine"
        class="inline-flex items-center text-sm text-gray-600 hover:text-gray-900 transition duration-150 ease-in-out"
        target="_blank"
      >
        Contribute on GitHub
        <svg class="ml-2 h-4 w-4" fill="currentColor" viewBox="0 0 24 24">
          <path
            d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"
          />
        </svg>
      </a>
    </div>
  </body>
</html>
